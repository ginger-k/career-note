函数的名字：一个包含指针的变量

return：如果不带任何返回值，函数在停止执行后返回undefined

函数内部对象
	arguments：与数组类似(并不是Array对象)，可以用[]访问每一个元素
		length，确定arguments的个数
		callee，指向拥有这个arguments对象的函数，用于与函数名解耦(递归函数)
	this：引用函数据以执行的环境对象

函数的属性：
	caller，保存着调用当前函数的函数的引用
	length，表示函数希望接收的命名参数的个数
	prototype，指向原型

函数的方法：
	apply()，call()，在特定的作用域中调用函数，扩充函数赖以运行的作用域，对象与方法解耦
	apply()，第一个参数是运行函数的作用域，第二个参数是数组
	call()，第一个参数是运行函数的作用域，之后逐个列举出传递给函数的参数
	bind()，参数是运行函数的作用域，这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值
		var color = 'red';
		var obj = {color: 'blue'};
		function sayColor(){console.log(this.color);}
		sayColor.call(window);
		sayColor.call(obj);
		var sayColorOfObj = sayColor.bind(obj); //创建一个函数，其this绑定到了obj
		sayColorOfObj();
	bind的简单原理
		Function.prototype.mybind = function(target) {
			var _self = this; //因为，内部函数要访问其外部的this
			return function() {
				return _self.apply(obj, arguments); //函数外部的任何this变量都不可见
			}
		}
		var color = 'red';
		var obj = {color: 'blue'};
		function sayColor(des){console.log(this.color + ' -- ' + des);}
		var sayColorOfObj = sayColor.mybind(obj);
		sayColorOfObj('哈');
	

传递参数：函数的参数都是按值传递的
	传递基本类型的值时，被传递的值会被复制给一个局部变量(arguments的一个元素)
	传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，这个局部变量的变化会反映到函数外部
	function setName(obj) {
            obj.name = "Nicholas"; //可以修改值
        }
        var person = new Object();
        setName(person);
        alert(person.name);    //"Nicholas"

	function setName(obj) {
            obj.name = "Nicholas"; 
	    obj = new Object();//不可以修改引用
	    obj.name = "Greg";
        }
        var person = new Object();
        setName(person);
        alert(person.name);    //"Nicholas"